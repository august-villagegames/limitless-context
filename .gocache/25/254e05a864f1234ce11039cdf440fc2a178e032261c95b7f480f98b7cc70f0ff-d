// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/augustcomstock/Desktop/limitless-context/pkg/video/recorder_darwin.go:1:1
//go:build darwin

package video

/*
#cgo CFLAGS: -x objective-c -fobjc-arc -fmodules
#cgo LDFLAGS: -framework Foundation -framework AVFoundation -framework ScreenCaptureKit -framework CoreMedia -framework CoreVideo -framework VideoToolbox
#include <stdlib.h>
#include "recorder_darwin.h"
*/
import _ "unsafe"

import (
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"sync"
	"time"
	"unsafe"
)

const permissionErrorPrefix = "SCREEN_RECORDING_PERMISSION_REQUIRED:"

type macRecorder struct {
	format string
	mu     sync.Mutex
}

func newNativeRecorder(format string) (NativeRecorder, error) {
	if format != "mp4" {
		return nil, fmt.Errorf("format %q is not supported on macOS recorder", format)
	}
	if ( /*line :35:5*/_Cfunc_recorder_initialize /*line :35:25*/)() != 0 {
		return nil, errors.New("screen recording frameworks are not available")
	}
	return &macRecorder{format: format}, nil
}

func (m *macRecorder) Record(ctx context.Context, dest string, filename string, started time.Time, duration time.Duration) (string, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	absDir, err := filepath.Abs(dest)
	if err != nil {
		return "", fmt.Errorf("resolve destination: %w", err)
	}
	absFile := filepath.Join(absDir, filename)

	durationSeconds := duration.Seconds()
	if durationSeconds <= 0 {
		return "", errors.New("duration must be positive")
	}

	cPath := ( /*line :56:11*/_Cfunc_CString /*line :56:19*/)(absFile)
	defer func() func() { _cgo0 := /*line :57:15*/unsafe.Pointer(cPath); return func() { _cgoCheckPointer(_cgo0, nil); /*line :57:37*/_Cfunc_free(_cgo0); }}()()

	errCh := make(chan error, 1)
	go func() {
		var cerr * /*line :61:13*/_Ctype_char /*line :61:19*/
		rc := func() _Ctype_int{ var _cgo0 *_Ctype_char = /*line :62:34*/cPath; var _cgo1 _Ctype_double = _Ctype_double /*line :62:49*/(durationSeconds); _cgoBase2 := /*line :62:68*/&cerr; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :62:74*/_Cfunc_recorder_record_screen(_cgo0, _cgo1, _cgo2); }()
		if cerr != nil {
			errMsg := ( /*line :64:14*/_Cfunc_GoString /*line :64:23*/)(cerr)
			( /*line :65:4*/_Cfunc_recorder_free_string /*line :65:25*/)(cerr)
			if strings.HasPrefix(errMsg, permissionErrorPrefix) {
				errCh <- newPermissionError(strings.TrimPrefix(errMsg, permissionErrorPrefix))
				return
			}
			errCh <- errors.New(errMsg)
			return
		}
		if rc != 0 {
			errCh <- fmt.Errorf("recording failed with status %d", int(rc))
			return
		}
		errCh <- nil
	}()

	if ctx != nil {
		select {
		case <-ctx.Done():
			( /*line :83:4*/_Cfunc_recorder_cancel_active /*line :83:27*/)()
			err := <-errCh
			if err != nil {
				return "", err
			}
			return "", ctx.Err()
		case err := <-errCh:
			if err != nil {
				return "", err
			}
		}
	} else {
		if err := <-errCh; err != nil {
			return "", err
		}
	}

	return absFile, nil
}
