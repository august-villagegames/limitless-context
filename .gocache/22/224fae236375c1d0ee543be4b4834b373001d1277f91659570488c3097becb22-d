// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/augustcomstock/Desktop/limitless-context/pkg/events/tap_darwin.go:1:1
//go:build darwin

package events

/*
#cgo darwin CFLAGS: -x objective-c -fmodules -fobjc-arc
#cgo darwin LDFLAGS: -framework CoreGraphics -framework ApplicationServices -framework Cocoa
#include <ApplicationServices/ApplicationServices.h>
#include <Cocoa/Cocoa.h>
#include <CoreFoundation/CoreFoundation.h>
#include <stdint.h>

static Boolean axCheckTrusted(void) {
        const void *keys[] = { kAXTrustedCheckOptionPrompt };
        const void *values[] = { kCFBooleanTrue };
        CFDictionaryRef options = CFDictionaryCreate(kCFAllocatorDefault, keys, values, 1,
                                                     &kCFTypeDictionaryKeyCallBacks,
                                                     &kCFTypeDictionaryValueCallBacks);
        Boolean trusted = AXIsProcessTrustedWithOptions(options);
        CFRelease(options);
        return trusted;
}

extern CGEventRef goHandleEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *userInfo);

static CFRunLoopSourceRef startEventTap(uintptr_t handle, CGEventMask mask, CFMachPortRef *tapOut) {
        CFMachPortRef tap = CGEventTapCreate(kCGSessionEventTap,
                                             kCGHeadInsertEventTap,
                                             kCGEventTapOptionListenOnly,
                                             mask,
                                             goHandleEvent,
                                             (void *)handle);
        if (tap == NULL) {
                return NULL;
        }
        CGEventTapEnable(tap, true);
        CFRunLoopSourceRef source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0);
        *tapOut = tap;
        return source;
}

static CFRunLoopRef currentRunLoop(void) {
        return CFRunLoopGetCurrent();
}

static CGEventMask cgEventMaskBit(CGEventType type) {
        return ((CGEventMask)1) << type;
}

static void addSourceToRunLoop(CFRunLoopRef loop, CFRunLoopSourceRef source) {
        CFRunLoopAddSource(loop, source, kCFRunLoopCommonModes);
}

static void runCurrentRunLoop(void) {
        CFRunLoopRun();
}

static void stopRunLoop(CFRunLoopRef loop) {
        CFRunLoopStop(loop);
}

static double cgEventGetX(CGEventRef event) {
        CGPoint point = CGEventGetLocation(event);
        return point.x;
}

static double cgEventGetY(CGEventRef event) {
        CGPoint point = CGEventGetLocation(event);
        return point.y;
}

static int64_t cgEventGetKeycode(CGEventRef event) {
        return CGEventGetIntegerValueField(event, kCGKeyboardEventKeycode);
}

static CFStringRef copyFocusedWindowTitle(void) {
        AXUIElementRef systemWide = AXUIElementCreateSystemWide();
        if (systemWide == NULL) {
                return NULL;
        }
        AXUIElementRef app = NULL;
        AXError err = AXUIElementCopyAttributeValue(systemWide, kAXFocusedApplicationAttribute, (CFTypeRef *)&app);
        if (err != kAXErrorSuccess || app == NULL) {
                if (app != NULL) {
                        CFRelease(app);
                }
                CFRelease(systemWide);
                return NULL;
        }
        AXUIElementRef window = NULL;
        err = AXUIElementCopyAttributeValue(app, kAXFocusedWindowAttribute, (CFTypeRef *)&window);
        if (err != kAXErrorSuccess || window == NULL) {
                if (window != NULL) {
                        CFRelease(window);
                }
                CFRelease(app);
                CFRelease(systemWide);
                return NULL;
        }
        CFStringRef title = NULL;
        err = AXUIElementCopyAttributeValue(window, kAXTitleAttribute, (CFTypeRef *)&title);
        if (window != NULL) {
                CFRelease(window);
        }
        CFRelease(app);
        CFRelease(systemWide);
        return title;
}

static CFStringRef copyFocusedAppBundle(void) {
        NSRunningApplication *app = [[NSWorkspace sharedWorkspace] frontmostApplication];
        if (app == nil) {
                return NULL;
        }
        NSString *bundleID = app.bundleIdentifier ?: @"";
        return (__bridge_retained CFStringRef)bundleID;
}

static CFStringRef copyFocusedAppName(void) {
        NSRunningApplication *app = [[NSWorkspace sharedWorkspace] frontmostApplication];
        if (app == nil) {
                return NULL;
        }
        NSString *name = app.localizedName ?: @"";
        return (__bridge_retained CFStringRef)name;
}
*/
import _ "unsafe"

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/cgo"
	"strconv"
	"sync"
	"time"
	"unsafe"
)

type macEventSource struct {
	now func() time.Time
}

func defaultEventSource(opts Options, clock func() time.Time) EventSource {
	return &macEventSource{now: clock}
}

type macEventStream struct {
	emit       func(Event) error
	now        func() time.Time
	loop        /*line :153:13*/_Ctype_CFRunLoopRef /*line :153:27*/
	stopped    chan struct{}
	stopLoop   func()
	err        error
	focusLock  sync.Mutex
	lastApp    string
	lastBundle string
	lastTitle  string
	closeOnce  sync.Once
}

func newMacEventStream(now func() time.Time, emit func(Event) error) *macEventStream {
	return &macEventStream{
		emit:    emit,
		now:     now,
		stopped: make(chan struct{}),
	}
}

func (s *macEventStream) close() {
	s.closeOnce.Do(func() {
		close(s.stopped)
	})
}

func (s *macEventStream) setErr(err error) {
	if err == nil {
		return
	}
	if s.err == nil {
		s.err = err
	}
}

func (s *macEventStream) emitEvent(event Event) {
	if s.err != nil {
		return
	}
	if err := s.emit(event); err != nil {
		s.setErr(err)
		if s.stopLoop != nil {
			s.stopLoop()
		}
	}
}

func (s *macEventStream) emitFocus(now time.Time) {
	meta := make(map[string]string)
	if title := cfStringToGo(( /*line :201:27*/_Cfunc_copyFocusedWindowTitle /*line :201:50*/)()); title != "" {
		meta["title"] = title
	}
	if name := cfStringToGo(( /*line :204:26*/_Cfunc_copyFocusedAppName /*line :204:45*/)()); name != "" {
		meta["app"] = name
	}
	if bundle := cfStringToGo(( /*line :207:28*/_Cfunc_copyFocusedAppBundle /*line :207:49*/)()); bundle != "" {
		meta["bundle"] = bundle
	}

	s.focusLock.Lock()
	changed := meta["app"] != s.lastApp || meta["bundle"] != s.lastBundle || meta["title"] != s.lastTitle
	if changed {
		s.lastApp = meta["app"]
		s.lastBundle = meta["bundle"]
		s.lastTitle = meta["title"]
	}
	s.focusLock.Unlock()

	if !changed {
		return
	}

	event := Event{
		Timestamp: now,
		Category:  "window",
		Action:    "focus",
		Target:    meta["bundle"],
		Metadata:  trimEmpty(meta),
	}
	s.emitEvent(event)
}

func (s *macEventStream) handleKeyboard(now time.Time, eventType  /*line :234:66*/_Ctype_CGEventType /*line :234:79*/, event  /*line :234:87*/_Ctype_CGEventRef /*line :234:99*/) {
	keycode := int(func() _Ctype_int64_t{ var _cgo0 _Ctype_CGEventRef = /*line :235:37*/event; return /*line :235:43*/_Cfunc_cgEventGetKeycode(_cgo0); }())
	meta := s.focusMetadata()
	meta["keycode"] = strconv.Itoa(keycode)
	action := "press"
	switch eventType {
	case ( /*line :240:7*/_Ciconst_kCGEventKeyUp /*line :240:21*/):
		action = "release"
	case ( /*line :242:7*/_Ciconst_kCGEventFlagsChanged /*line :242:28*/):
		action = "modifier"
	}
	s.emitEvent(Event{
		Timestamp: now,
		Category:  "keyboard",
		Action:    action,
		Target:    fmt.Sprintf("key:%d", keycode),
		Metadata:  meta,
	})
}

func (s *macEventStream) handleMouse(now time.Time, eventType  /*line :254:63*/_Ctype_CGEventType /*line :254:76*/, event  /*line :254:84*/_Ctype_CGEventRef /*line :254:96*/) {
	meta := s.focusMetadata()
	x := float64(func() _Ctype_double{ var _cgo0 _Ctype_CGEventRef = /*line :256:29*/event; return /*line :256:35*/_Cfunc_cgEventGetX(_cgo0); }())
	y := float64(func() _Ctype_double{ var _cgo0 _Ctype_CGEventRef = /*line :257:29*/event; return /*line :257:35*/_Cfunc_cgEventGetY(_cgo0); }())
	meta["x"] = fmt.Sprintf("%.2f", x)
	meta["y"] = fmt.Sprintf("%.2f", y)

	action := "move"
	switch eventType {
	case ( /*line :263:7*/_Ciconst_kCGEventLeftMouseDown /*line :263:29*/):
		action = "left-down"
	case ( /*line :265:7*/_Ciconst_kCGEventLeftMouseUp /*line :265:27*/):
		action = "left-up"
	case ( /*line :267:7*/_Ciconst_kCGEventRightMouseDown /*line :267:30*/):
		action = "right-down"
	case ( /*line :269:7*/_Ciconst_kCGEventRightMouseUp /*line :269:28*/):
		action = "right-up"
	case ( /*line :271:7*/_Ciconst_kCGEventOtherMouseDown /*line :271:30*/):
		action = "other-down"
	case ( /*line :273:7*/_Ciconst_kCGEventOtherMouseUp /*line :273:28*/):
		action = "other-up"
	case ( /*line :275:7*/_Ciconst_kCGEventScrollWheel /*line :275:27*/):
		action = "scroll"
	}

	s.emitEvent(Event{
		Timestamp: now,
		Category:  "mouse",
		Action:    action,
		Target:    meta["app"],
		Metadata:  meta,
	})
}

func (s *macEventStream) focusMetadata() map[string]string {
	meta := make(map[string]string)
	s.focusLock.Lock()
	if s.lastApp != "" {
		meta["app"] = s.lastApp
	}
	if s.lastBundle != "" {
		meta["bundle"] = s.lastBundle
	}
	if s.lastTitle != "" {
		meta["title"] = s.lastTitle
	}
	s.focusLock.Unlock()
	return meta
}

func trimEmpty(meta map[string]string) map[string]string {
	if len(meta) == 0 {
		return nil
	}
	cleaned := make(map[string]string, len(meta))
	for k, v := range meta {
		if v == "" {
			continue
		}
		cleaned[k] = v
	}
	if len(cleaned) == 0 {
		return nil
	}
	return cleaned
}

func cfStringToGo(str  /*line :321:23*/_Ctype_CFStringRef /*line :321:36*/) string {
	if str == 0 {
		return ""
	}
	defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :325:31*/(str); return func() { /*line :325:37*/_Cfunc_CFRelease(_cgo0); }}()()
	length := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFStringRef = /*line :326:32*/str; return /*line :326:36*/_Cfunc_CFStringGetLength(_cgo0); }()
	if length == 0 {
		return ""
	}
	bufSize :=  /*line :330:13*/_Ctype_CFIndex /*line :330:22*/(1 + 4*length)
	buf := make([]byte, int(bufSize))
	if func() _Ctype_Boolean{ var _cgo0 _Ctype_CFStringRef = /*line :332:26*/str; var _cgo1 *_Ctype_char = /*line :332:31*/(*_Ctype_char /*line :332:39*/)(unsafe.Pointer(&buf[0])); var _cgo2 _Ctype_CFIndex = /*line :332:67*/bufSize; var _cgo3 _Ctype_CFStringEncoding = /*line :332:76*/_Ciconst_kCFStringEncodingUTF8 /*line :332:99*/; return /*line :332:100*/_Cfunc_CFStringGetCString(_cgo0, _cgo1, _cgo2, _cgo3); }() ==  /*line :332:104*/_Ctype_Boolean /*line :332:113*/(0) {
		return ""
	}
	return ( /*line :335:9*/_Cfunc_GoString /*line :335:18*/)((* /*line :335:22*/_Ctype_char /*line :335:28*/)(unsafe.Pointer(&buf[0])))
}

func (s *macEventSource) Stream(ctx context.Context, emit func(Event) error) error {
	if ( /*line :339:5*/_Cfunc_axCheckTrusted /*line :339:20*/)() ==  /*line :339:27*/_Ctype_Boolean /*line :339:36*/(0) {
		return ErrAccessibilityPermission
	}
	if ctx == nil {
		ctx = context.Background()
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	stream := newMacEventStream(s.now, emit)
	handle := cgo.NewHandle(stream)
	defer handle.Delete()

	mask := ( /*line :353:10*/_Cfunc_cgEventMaskBit /*line :353:25*/)(( /*line :353:27*/_Ciconst_kCGEventKeyDown /*line :353:43*/)) |
		( /*line :354:3*/_Cfunc_cgEventMaskBit /*line :354:18*/)(( /*line :354:20*/_Ciconst_kCGEventKeyUp /*line :354:34*/)) |
		( /*line :355:3*/_Cfunc_cgEventMaskBit /*line :355:18*/)(( /*line :355:20*/_Ciconst_kCGEventFlagsChanged /*line :355:41*/)) |
		( /*line :356:3*/_Cfunc_cgEventMaskBit /*line :356:18*/)(( /*line :356:20*/_Ciconst_kCGEventLeftMouseDown /*line :356:42*/)) |
		( /*line :357:3*/_Cfunc_cgEventMaskBit /*line :357:18*/)(( /*line :357:20*/_Ciconst_kCGEventLeftMouseUp /*line :357:40*/)) |
		( /*line :358:3*/_Cfunc_cgEventMaskBit /*line :358:18*/)(( /*line :358:20*/_Ciconst_kCGEventRightMouseDown /*line :358:43*/)) |
		( /*line :359:3*/_Cfunc_cgEventMaskBit /*line :359:18*/)(( /*line :359:20*/_Ciconst_kCGEventRightMouseUp /*line :359:41*/)) |
		( /*line :360:3*/_Cfunc_cgEventMaskBit /*line :360:18*/)(( /*line :360:20*/_Ciconst_kCGEventOtherMouseDown /*line :360:43*/)) |
		( /*line :361:3*/_Cfunc_cgEventMaskBit /*line :361:18*/)(( /*line :361:20*/_Ciconst_kCGEventOtherMouseUp /*line :361:41*/)) |
		( /*line :362:3*/_Cfunc_cgEventMaskBit /*line :362:18*/)(( /*line :362:20*/_Ciconst_kCGEventMouseMoved /*line :362:39*/)) |
		( /*line :363:3*/_Cfunc_cgEventMaskBit /*line :363:18*/)(( /*line :363:20*/_Ciconst_kCGEventScrollWheel /*line :363:40*/))

	var tap  /*line :365:10*/_Ctype_CFMachPortRef /*line :365:25*/
	source := func() _Ctype_CFRunLoopSourceRef{ var _cgo0 _Ctype_uintptr_t = _Ctype_uintptr_t /*line :366:39*/(handle); var _cgo1 _Ctype_CGEventMask = /*line :366:49*/mask; _cgoBase2 := /*line :366:55*/&tap; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :366:60*/_Cfunc_startEventTap(_cgo0, _cgo1, _cgo2); }()
	if source == 0 {
		return errors.New("failed to create CGEvent tap")
	}
	defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :370:31*/(source); return func() { /*line :370:40*/_Cfunc_CFRelease(_cgo0); }}()()
	defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :371:31*/(tap); return func() { /*line :371:37*/_Cfunc_CFRelease(_cgo0); }}()()

	loop := ( /*line :373:10*/_Cfunc_currentRunLoop /*line :373:25*/)()
	stream.loop = loop
	stopOnce := sync.Once{}
	stream.stopLoop = func() {
		stopOnce.Do(func() {
			func() { var _cgo0 _Ctype_CFRunLoopRef = /*line :378:18*/loop; /*line :378:23*/_Cfunc_stopRunLoop(_cgo0); }()
		})
	}
	func() { var _cgo0 _Ctype_CFRunLoopRef = /*line :381:23*/loop; var _cgo1 _Ctype_CFRunLoopSourceRef = /*line :381:29*/source; /*line :381:36*/_Cfunc_addSourceToRunLoop(_cgo0, _cgo1); }()

	cancelWatcher := make(chan struct{})
	go func() {
		select {
		case <-ctx.Done():
			stream.stopLoop()
		case <-stream.stopped:
		}
		close(cancelWatcher)
	}()

	stream.emitFocus(stream.now().UTC())
	( /*line :394:2*/_Cfunc_runCurrentRunLoop /*line :394:20*/)()
	stream.stopLoop()
	stream.close()
	<-cancelWatcher
	if stream.err != nil {
		return stream.err
	}
	if err := ctx.Err(); err != nil {
		return err
	}
	return nil
}

//export goHandleEvent
func goHandleEvent(_  /*line :408:22*/_Ctype_CGEventTapProxy /*line :408:39*/, eventType  /*line :408:51*/_Ctype_CGEventType /*line :408:64*/, event  /*line :408:72*/_Ctype_CGEventRef /*line :408:84*/, userInfo unsafe.Pointer)  /*line :408:111*/_Ctype_CGEventRef /*line :408:123*/ {
	handle := cgo.Handle(uintptr(userInfo))
	streamIface := handle.Value()
	stream, ok := streamIface.(*macEventStream)
	if !ok {
		return event
	}

	now := stream.now().UTC()
	stream.emitFocus(now)

	switch eventType {
	case ( /*line :420:7*/_Ciconst_kCGEventKeyDown /*line :420:23*/), ( /*line :420:26*/_Ciconst_kCGEventKeyUp /*line :420:40*/), ( /*line :420:43*/_Ciconst_kCGEventFlagsChanged /*line :420:64*/):
		stream.handleKeyboard(now, eventType, event)
	case ( /*line :422:7*/_Ciconst_kCGEventLeftMouseDown /*line :422:29*/), ( /*line :422:32*/_Ciconst_kCGEventLeftMouseUp /*line :422:52*/),
		( /*line :423:3*/_Ciconst_kCGEventRightMouseDown /*line :423:26*/), ( /*line :423:29*/_Ciconst_kCGEventRightMouseUp /*line :423:50*/),
		( /*line :424:3*/_Ciconst_kCGEventOtherMouseDown /*line :424:26*/), ( /*line :424:29*/_Ciconst_kCGEventOtherMouseUp /*line :424:50*/),
		( /*line :425:3*/_Ciconst_kCGEventMouseMoved /*line :425:22*/), ( /*line :425:25*/_Ciconst_kCGEventScrollWheel /*line :425:45*/):
		stream.handleMouse(now, eventType, event)
	default:
		// ignore other events
	}

	return event
}
